# 如何使用汇编指令编写一个简单的C程序

## 写在前面

​	em,虽然但是，这两天没得写推文，原因就是我真的在很认真的掰扯这个`RISC-V`汇编指令集。刚开始入手的时候，就跟第一次学`csapp`一样，就是一个一个指令拆开来看，我都认识，一个一个寄存器拆开来看，我也都认识，可是当他们全都放在一起，并以一种`amazing`的组合方式出现的时候，我就完全带着四个眼睛瞪着屏幕，干瞪眼。所以，在我遇到这个东西的时候，第一时间就是找答案，但不得不说`CS61C`真的做的挺好的，全网估计都没有什么答案。之前在网上看到一个博客说，伯克利的老师还专门说让热心的分享者下架答案。所以我怀着怀疑的心态做完了`lab3`。

## 关于RISC-V

​	在一些寒暄之后，进入今天的正题。`RISC-V`精简指令集，but精简指令集为啥叫精简指令集，真的不知道，还是去`Bing`一下。

![image-20221021002445130](https://s2.loli.net/2022/10/21/Kh5oALXUkuFfJs6.png)

​	大致的意思就是这个指令集非常的简单，非常的容易设计小型系统。于是乎，就开始上手了，但是最开始上手的时候呢，并不是直接去写汇编代码，而是一步一步来。

​	首先，在一切开始之前，需要找到一个比较不错的可视化工具。所以,`Venus`来啦，我愿称之为`RISC-V`最好的汇编可视化工具。在这里，你可以看到所有的数据变化，包括内存，包括寄存器，甚至还有`cache`，为什么说他最好呢，是因为每一步我都可以找到数据的变化，从而更充分的理解指令的意义（还有就是更好的理解内存变化）。

![网页捕获_20-10-2022_233644_venus.cs61c.org](https://s2.loli.net/2022/10/20/pbVnWkrUAiLIz7H.jpg)

​	所以，我花了一个晚上熟悉它。具体说来就是真实的拿出来一段汇编代码在上面跑一遍，然后跟踪每个指令，如果写入了内存，就去内存里看是不是发生了变化，如果更新了寄存器，就去看寄存器里新增加的是什么，是内存的地址还是值。曾经有位老师说过，做好一件事情，只需要三到："心到，时间到，钱到"；就一定可以做好。所以在没有钱的前提下，我只是简单的总结出来了一些不算太精典的规律。

### 开辟栈空间

​	在这之前，因为一直刷算法用的是`python`，所以对于这种概念真的没感觉，除非是要用到深度优先搜索才会觉得要注意栈的使用。所以一开始我就吃大亏了，在刚开始要开辟栈空间的时候，我以为随便给它分配一个空间`malloc`一下就完事儿了，后来才发现大错特错了。

​	在这里，为了保证我自己讲的清楚一点，我会加一点点基础进来。首先就是内存的构成，是由五个部分构成。

（从上到下的顺序）`Stack` `Heap` `Data` `Code`，用图形化表示是这样的。

![memory](https://s2.loli.net/2022/10/21/u4tmInejYDFUvRC.png)

​	这里的栈其实就是指的是内存中的栈，而我们说开辟栈空间其实就是将记录栈最低位置的`sp`栈指针向下移动，从最顶端到`sp`都是栈的空间，这样就是开辟了一块空间。然后有意思的就来了，这里的栈空间到底开辟了用来干嘛。其实很简单，用来存放变量，就像上面这张图说的一样，存放寄存器和本地变量。

​	现在问题就来了，我怎么知道我现在写的汇编代码中哪一个是变量的，我就只知道`x0`寄存器可以表示一个常数0，别的都没有说明的，好了，那关于汇编代码我们只考虑寄存器的保存。可是什么情况下需要保存寄存器的值呢？别问我，因为我也不知道，但是有位大哥就说的贼清晰。如果不想听我娓娓道来，就可以直接去看看这位大哥口中描述的`caller register`和`callee register`。推荐的原因其实很简单的了，因为我也是看完之后才有很大的启发。

> RISC-V Bytes: Caller and Callee Saved Registers · Daniel Mangum
>
> https://danielmangum.com/posts/risc-v-bytes-caller-callee-registers/	

### 寄存器值的保存和使用	

​	其实关于寄存器的保存，无非就因为寄存器太少了，但也不能说太少了，因为如果太多寄存器访问就会变慢。只能说为了达到最高的执行效率吧。而保存的寄存器其实也就两三个，我们经常用的`ra`，如果不熟悉`RISC-V`指令的朋友，可以简单把他理解成`pc`（程序计数器），当我们想去在一个函数里面调用另外一个函数的时候（或者一种更为亲切地表达在一个label下面想要去跳到另外一个label下面执行），一般来说，可以用`j label` `jal ra label` 这两种方法来进行无条件跳转，`j label`指的就是直接跳转，遇到这条指令跳转就对了。还有就是`jal ra label`，`jal`的全称是jump and link 就是也执行跳转，但是同时记录当前pc值并加4。这里先给出RISC-V的寄存器的值。

| Name    | ABI Mnemonic | Calling Convention  | Preserved across calls? |
| ------- | ------------ | ------------------- | ----------------------- |
| x0      | zero         | Zero                | n/a                     |
| x1      | ra           | Return address      | No                      |
| x2      | sp           | Stack pointer       | Yes                     |
| x3      | gp           | Global pointer      | n/a                     |
| x4      | tp           | Thread pointer      | n/a                     |
| x5-x7   | t0-t2        | Temporary registers | No                      |
| x8-x9   | s0-s1        | Saved registers     | Yes                     |
| x10-x17 | a0-a7        | Argument registers  | No                      |
| x18-x27 | s2-s11       | Saved registers     | Yes                     |
| x28-x31 | t3-t6        | Temporary registers | No                      |

​	跳转之后，这时候有一个问题，我怎样回到我原来的位置呢？或者具体地说，我怎样回到pc值指定的位置呢？这个时候`ra`的作用就体现出来了，直接使用`jr ra`直接跳转到`ra`寄存器里记录的地址，也就是我们之前跳转之前的下一个位置对吧。好了，这只是一个简单的例子，那么下面再来一个复杂的例子。

```bash
# call main
<0x0>	jal ra, map
……………………………………………………………………………………………………………………
map:
<0x4>	addi sp, sp, -8
<0x8>	beq a0, x0, done
<0xc>	sw s0, 4(sp)        # store the stack frame address
<0x10>	sw ra, 0(sp)        # store the return address
<0x14>  jal ra, square
<0x18>	jal ra, map
done:
<0x1c>  addi sp, sp, 8
<0x24>  lw ra, 0(sp)
<0x28>  lw s0, 4(sp)
<0x2c>  jr ra # Return to caller
```

​	我们在这里首先调用的是`call map`，这里的pc值指向的是`<0x4>`，也就是调用后的下一条指令，但是现在我们需要进入的是map函数里面，我们会发现，这里面还有函数调用`<0x8>`，按照之前的思路继续使用`jal ra label`，就会发现一个神奇的事情，`ra`寄存器被覆盖了，然后我们就再也没有办法回到`<0x4>`了。所以，这里就用到上面提到的栈存储了。

​	在开辟出栈空间之后，需要做的是将之前的`pc`放进栈里。而观察这个汇编代码会发现，其实开辟栈空间很容易，就是让栈指针寄存器`sp`向下移动，而除了需要存储`pc`，似乎这里还需要存储别的值。这里可以这样做出假设，如果说`ra`里存放的是调用程序的返回信息，那么`s0`就是被调用程序的信息。而递归程序则是说明这个假设的最好例子。

​	如果有一个递归程序，每次循环都会更新`pc`也就是我们说的`ra`，而每次递归的变量也会发生变化，但是并没有消失，而是存储在递归栈里，所以在这里抽象一下，每个函数在运行的时候都会得到自己的一个小空间里面存放自己的变量，在运行完之后才会被释放。而在这里，你可以把`s0`寄存器想象成为这个小空间的开头。或者比较准确的说法，这个`s0`叫栈帧。

​	经过上面的说明之后，因为`s0`里存储的是当前程序的变量的地址，如果不存储的话后面就会被覆盖，就会丢失数据。所以又一次用到了`sp`。

​	寄存器的保存已经完成了，那怎样去使用呢？这里只讨论关于在内存中进行存储的寄存器，如`ra , s0`等寄存器。因为已经存入到内存中去了，那使用的时候直接就拿出来了呗，但是在拿出来之前，难道你都没有一点疑惑，如果每次都使用同一个位置的`sp`，那不是也被同样覆盖了嘛。如果你有这样的问题，那我很高兴你已经听懂我前面在讲什么了，是的，所以在每次进入函数的时候都要在内存中为之分配空间来存储我们的寄存器，同时移动栈指针`sp`。

​	在前面已经提到，如果返回只需要直接跳进`ra`就可以回到调用之前的`pc`的下一条指令，但是在上面这个例子来看，pc值一直在变，已经没有办法直接找到原来的地址了，这个时候使用寄存器的高级方法就来了，之前存储的`ra`值也开始用了，将`sp`里对应的`ra`返回给`ra`,同时需要更新`sp`的值来得到依次调用之前存在递归栈里的地址和栈帧变量。

### 系统函数调用

​	综合来说，我觉得最搞笑的就是这一部分，在做完之后看到有相关的文档介绍的时候，我就真的是大眼瞪小眼，我是谁，我在哪，我在干啥。因为系统调用就一个`ecall`指令，之前在听课的时候还以为随即指定的，但是跟踪程序之后我就发现了使用`ecall`的小窍门，这个指令一般会依靠两个寄存器，`a0 和 a1`，调用函数的参数。所以有时候就会在`ecall`指令附近发现`a0 a1`寄存器的变化，比如下面这样。

```bash
 add t0, a0, x0  # t0 gets current node address
 lw  a1, 0(t0)   # a1 gets value in current node
 addi a0, x0, 1      # prepare for print integer ecall
 ecall
 addi    a1, x0, ' '     # a0 gets address of string containing space
 addi    a0, x0, 11      # prepare for print string syscall
 ecall
```

​	关于`ecall`指令具体的调用代码，这里给出一个参考文档。

> RISC-V Syscall 系列1：什么是 Syscall ? - 泰晓科技 (tinylab.org)
>
> https://tinylab.org/riscv-syscall-part1-usage/

## 结语

​	是的，其实不是很多，但确实我花了两天的时间来做，在一遍一遍的跟踪每个寄存器和内存里的值之后，得到了这些不成规律的规律。与其说我学会了汇编代码，倒不如说我更了解计算机程序底层是怎么运行的。其实在做完之后，我最大的感触不是我做的有多么的华丽，而是这个过程，有了一个全新的体验，不同于被迫去完成，也不同于侥幸直接通过实验。我所感受的是一种踏踏实实，一步一步完成一个不算很复杂的实验的满足感。在跟踪每个寄存器的值的时候，硬是被磨到没脾气。还有就是真的要学会独立的思考，思考下一步要干什么，以及你想要的效果是什么样的。然后一步一步朝着那个效果去修改就可以很快的完成。但这一切一切的前提是你的足够了解常用的指令。

​	抛开实验，我觉得大学似乎也是这样的，不同于中学时候的给定目标值，大家一同去朝着同一个方向走，只需要看旁边的人在干嘛，稍稍模仿一下就可以了。大学就是相同开局，没有标准答案，但是都期待美好，只有最终的评判标准，所以中间的过程完全都是自己决定的，不仅要确立目标，还要不断朝着每一个分目标前进，还要确保在朝着目标的前进时保质保量。所以我们一直在向前。

​	最后，同样祝大家可以收获今天心满意足的自己:gift_heart: