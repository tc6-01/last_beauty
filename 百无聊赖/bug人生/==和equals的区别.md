## 前置知识

- java基本数据类型和引用类型
- java内存分布
  - 常量池
  - 堆区

## 问题描述

```java
if ("POST".equals(method)){
    
}

if ("POST" == method){
    
}
```

起初以为这两个家伙应该是等价的。

但发现效果不太一样，特地来了解一下

## 掌握基本数据类型和引用类型的概念

### 八大基本数据类型

>  Byte，short，int，long，double，folat，boolean，char
>
> 其中byte占一个字节，short和char占两个字节，int，float占四个字节，double和long占8个字节，boolean只有true和false，这八种数据变量中直接存储值
>
> 注意：八大基本数据类型对应着各自的封装类型的**包装类**，提供了更多的方法，且不进行初始化时值默认为空（基本数据类型必须初始化），并且属于**引用类型**

### 引用类型

> 引用类型主要是一些**类、接口、数组**
> 引用类型变量中存储的是**地址**，对应的**地址存储数据**

### '==' 和'equals'的区别

#### 作用对象

'=='可以作用于基本数据类型和对象。即"=="比较基本数据类型时比较的是表面值内容，而比较两个对象时比较的是两个对象的内存地址值。

而equals方法则只能作用于对象

#### 作用效果

一般的基本数据类型对应的包装类是提供了equals方法的重写的。因此，对于这些引用类型，其equals方法是比较其对象的内容。就是实际的值。

> == 在基本数据类型：值内容, 引用类型时：地址
> equals 重写：值内容 ， equals不重写：地址

### 类型转换

提到这个的原因是因为有些地方会有些定义长这个样子

```java
int a = 10;
// 基础数据类型的定义
Integer a = 10;
// 提供装箱的包装类定义。即先将10变成1个Integer对象，然后再将这个对象的地址赋给a，
// 而且这个Integer对象存放在内存中的常量池，如果有另外一个创建需求，比如Integer b = 10；
// 则会先去查找常量池里有没有10这个Integer对象，如果有，直接将地址传给b，
// 如果没有，创建一个放在常量池中
Integer a = new Integer(10); 
// 创建新Integer对象定义。
```

所以需要考虑的主要有两点

- 比较的是地址还是值
  - 确定比较的是对象还是基本数据类型
  - 确定用的方法是比较的是地址还是值
- 确定创建对象的地址是否一致
  - 确定是否为同一个对象
  - 确定是否为同一个地址